# AffineCarpetProject
## Introduction
This project was created to collect data for my Summer 2020 REU with the University of Conneticut. During this REU, my research group studied a [fractal](https://en.wikipedia.org/wiki/Fractal) called the [Affine Sierpinski Carpet](https://demonstrations.wolfram.com/SelfAffineVariantsOfTheSierpinskiCarpet/), which is a generalized version of the more well-known [Sierpinski Carpet](https://en.wikipedia.org/wiki/Sierpinski_carpet). Specifically, we studied how the resistance of the fractal changed as the precarpet level increased. The bounds for this value are closly related to two objects that are easier to compute than the continuous shape, the cross graph and the x graph representation of the precarpet.
### What is a precarpet?
A true fractal is a shape that has had a function applied to it an infinite amount of times, which is impossible to do on a computer. However, a precarpet only has the function applied to it a finite number of times, making it computable. The number of times the function is applied to the precarpet is dependent on its level. So, for the self-similar Sierpinski Carpet, a level 0 precarpet is the unit square, the level 1 precarpet is 8 unit squares assembled into a square, the level 2 precarpet is 8 level 1 precarpets assembled in a square, and so on.
### How do we represent these with cross and X graphs?
Any level affine precarpet is a collection of squares and rectangles. Level 0 is one square, level 1 is four squares and four rectangles, A cross graph replaces each of these rectangles with a "+" shape. The center point goes into the middle of the rectangle and each outer point, all of which share an edge with the center point, is placed at the middle of the side it extends to. An X graph replaces each rectangle with an "x" shape. The center point again goes into the middle of the shape it has replaced, but instead the vertices go into the corners of the rectangle.
### What is resistance?
Resistance in mathematics is analogous to resistance in electrical circuits. But before discussing resistance, we must discuss graph energy. When a function is applied to a graph (that is to say, each vertex in a graph is assigned a numerical value), the energy is half the sum of all the squared differences between every point's function value and all its neighbors' function values. Intuitively, it represents how much variation exists between the function values of neighboring points. Resistance is the reciprocal of the lowest possible energy the graph can have. While any function on a graph can have its energy calculated, a graph itself has a unique resistance value dependent on finding the function that gives the lowest possible energy. The unique function that accomplishes this is called the harmonic function.
### How do we calculate the harmonic function?
We use what is known as [relaxation](https://en.wikipedia.org/wiki/Relaxation_(iterative_method)). The harmonic function has the averaging property, meaning that each point's harmonic function value will be the average of its neighbor's harmonic function values. This allows the problem of finding the harmonic function to become a system of linear equations, allowing the relaxation method to work. It is implemented into the code as follows:
1) Apply an arbitrary function to all the points on the graph
2) Loop through all the points, changing their function values to be the average of their neighbors' function values (this is referred to as one relaxation)
3) Repeat step 2 as many times as is necessary for an accurate estimate
The closer the arbitrary function applied in step 1 is to the values of the true harmonic, the less times step 2 will need to be repeated. Typically, about 500 relaxations or more are needed to calculate useful estimates when using the method used in this program to apply the initial function (this is discussed in the __Generating Carpets__ section).
## How to Collect Affine Carpet Data
#### Generating Precarpets and Harmonic Function Data
To calculate the resistance of affine crosswire and X carpets, the carpets first have to be made and have the harmonic function applied to them. ``saveHarmonicFunction.py`` is dedicated to this purpose. Lines 8 to 18 serve as the input for the user to define which carpet they would like to calculate. 

The first input variable is ``precarpet_level``, which determines what level of precarpet you want. Before making a precarpet of level n, precarpet level n-1 of that affine carpet must first be made. This is because the initial function applied when calculating the harmonic function is created from the previous level's harmonic function (every cross or X is turned into a level 1 precarpet matching the dimensions of the cross or X) to allow for the best estimates with the least amount of relaxations.

The next input variable is ``sideOFSmallSquares``. This is how large the 4 small squares in the corners will be. The value must be between 0 and 1, as this program assumes all affine carpets have side lengths of 1x1 (before stretching, which I'll discuss shortly). Because of this assumption, the affine carpet can be defined by just this one variable, making it easy to sort the data made by this project.

The third input is ``numRuns``, which decides how many relaxations are run after the initial function is placed onto. In my experience, the optimal amount of runs is dependent on how high of a carpet level you're working with. A level 1 carpet will take about 30 seconds to apply 100,000 relaxations, giving you a very accurate base to start with and not take too much time to compute. Later levels take exponentially longer per relaxation, so having the previous levels be as accurate as possible can reduce the computing time needed for good estimates of harmonic functions by a huge amount. This number is also recorded in the data for the carpet, so you can see how accurate the estimate is.

The fourth variable is ``kindOfGraph``, which is simply a string with the value of "+" or "x". This determines whether a cross or X graph, respectively, is calculated. The two carpets require completely different constructions, so the data is sorted by cross graphs and X graphs. Having the level 3 cross graph for an affine carpet will not allow you to create the level 4 X graph.

The final variable is ``stretchFactor``, which determines how much the built carpet is stretched before having the harmonic function applied to it. Because affine precarpets have many different precarpets within them stretched to different levels, this data is useful for analyzing higher level carpets.
#### Storing Harmonic Function Data
The data is stored in two seperate directories, ``crossGraphData`` and ``xGraphData``. Within these folders, there are many different folders with the labeling scheme ``[sizeOfSmallSquares]affineCarpet1x[stretchFactor]``. These folders contain the text files which other scripts use to reconstruct the precarpets (as well as other files, which will be discussed later), which prevents having to start from scratch for every calculation. These files are simply labeled ``level[precarpet_level].txt``, as further context of which affine carpet is is comes from the directory that holds the file.
#### Calculating and Storing Resistance Data
The script ``resistanceSaver.py`` allows the user to calculate the resistance of any carpet that had its data generated and stored by ``saveHarmonicFunction.py``. The input section (lines 5 to 16) shares 4 variables with this script: ``precarpet_level``, ``sideOfSmallSquares``, ``kindOfGraph``, and ``stretchFactor``. The program can only run if ``saveHarmonicFunction.py`` has been run with the same input variables above already. The final variable is ``scalingFactor``, which multiplies the calculated resistance by a scaling factor. This is used for finding the resistance of carpets with a different size than 1x``stretchFactor``. The resistance is saved in the same directory as the data for the carpets under the name ``level[precarpet_level]resistance.txt``. Again, further context for what carpet this is comes from the directory it's in. This text file also stores the ``scalingFactor`` variable used, but only one resistance with one corresponding ``scalingFactor`` can be saved at a time (unless the file is manually renamed to something else, but scripts using this value will be looking for files specifically named what this script originally names them, so be sure to rename them back to the original name if you want to create some graphs using this data). 
#### Images of the Carpets
The affine carpet graphs and their respective harmonic functions can be visualized in a 3D graph. The graphs are 2D, so each point has an x and a y coordinate. Each point also has a value when inputted into the harmonic function, and this value can be used as the z coordinate. ``imageFromGraphFile.py`` and ``directedImageFromGraphFile.py`` both use this technique to generate matplotlib plots of the affine carpets. The former creates a scatter plot of each vertex, while the latter creates a line graph image of the carpet. Both scripts take the 4 carpet-identifying inputs, ``precarpet_level``, ``sideOfSmallSquares``, ``kindOfGraph``, and ``stretchFactor``. The carpet desired needs to already have been generated by ``saveHarmonicFunction.py``. The plots created by ``imageFromGraphFile.py`` and ``directedImageFromGraphFile.py`` will be saved as ``level[precarpet_level].pdf`` or ``level[precarpet_level]lineGraph.pdf``, respectively. Once again, further information about what carpet is in the file comes from the directory that the file is stored in.
#### Resistance and Rho Graphs
Rho is how much resistance increases from one precarpet's level to the 
